<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>图的DFS、BFS算法细节</title>
    <url>//posts/undefined/</url>
    <content><![CDATA[<p>深度优先算法（DFS）和广度优先算法（BFS）在许多<strong>树</strong>和<strong>图</strong>的问题上都能派上用场。基于树的DFS、BFS比较简单，但基于图DFS、BFS在传参的时候有一些小细节得注意一下。不同于树，由于树具有层次结构，所以可以用一个int类型的值来表示各个节点；图则不然，需要通过（x，y）坐标的形式来表示各个节点，所以在代码编写时传递图节点（x，y）时，有哪些是值得注意的呢？</p>
<span id="more"></span>

<p>首先，不管是树还是图，<strong>DFS</strong>都是基于<strong>递归</strong>编写的，<strong>BFS</strong>是基于<strong>队列</strong>编写的。  </p>
<ul>
<li>对于<strong>树</strong>来说，因为其<strong>具有</strong>的<strong>父与子</strong>的层次结构，DFS和BFS按上下次序遍历即可；  </li>
<li>而对于<strong>图</strong>，其结构是<strong>无上下层次</strong>的，顾在对其遍历时，我们会<strong>设置一个bool数组</strong>来记录结点是否已访问，以避免重复遍历。</li>
</ul>
<h3 id="邻接矩阵版-DFS、BFS代码编写时图节点的传参："><a href="#邻接矩阵版-DFS、BFS代码编写时图节点的传参：" class="headerlink" title="邻接矩阵版 DFS、BFS代码编写时图节点的传参："></a><em>邻接矩阵版</em> DFS、BFS代码编写时图节点的传参：</h3><p>代码中有两种参数需要注意：<strong>node型的点</strong> 和 <strong>int型的点</strong>，而需注意传参的函数有<strong>bool judge()<strong>和</strong>void BFS()/DFS()<strong>。<br>首先两者的</strong>bool judge(int x,int y)<strong>适用传入x，y值，而对于</strong>BFS()和DFS()<strong>函数的参数则没有限制，传</strong>单int</strong>(int v)、<strong>node</strong>或者<strong>双int</strong>(int x,int y)都行，但node型结构体都得定义。  </p>
<h3 id="如何将双int型-x-y-匹配到node型呢？"><a href="#如何将双int型-x-y-匹配到node型呢？" class="headerlink" title="如何将双int型(x,y)匹配到node型呢？"></a>如何将<strong>双int型(x,y)<strong>匹配到</strong>node型</strong>呢？</h3><p>1.对于传x,y的BFS，node只作为队列的变量，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">truequeue&lt;node&gt; Q;</span><br><span class="line">truenode Node;</span><br><span class="line">trueNode.x=x,Node.y=y;</span><br><span class="line">trueQ.<span class="built_in">push</span>(Node);</span><br><span class="line">    flag[x][y]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">     ...   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里node的作用仅是用来便于存储队列里的(x,y)点；</p>
<p>​        2.对于传node的BFS，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(node S)</span></span>&#123;</span><br><span class="line">truequeue&lt;node&gt; Q;</span><br><span class="line">trueQ.<span class="built_in">push</span>(S);</span><br><span class="line">true<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">truetrue...</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，<strong>queue Q里永远存的是node型</strong>，但如果直接传node型，将难以记录<strong>连通块</strong>的个数</p>
<p>总结：  </p>
<ol>
<li>对于大多数情况：bool judge的参数为(int x,int y);  </li>
<li>DFS<strong>两种都行</strong>(int x,int y)/DFS(int v),分别对应<strong>bool flag[x] [y]<strong>和</strong>bool flag[v]</strong>;  </li>
<li>BFS也是<strong>两种都行</strong>(int x,int y)/BFS(int v),如上。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>算法</tag>
        <tag>图</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>声明</title>
    <url>//posts/null/</url>
    <content><![CDATA[<p>本博客模板是在“班班”的博客<a href="https://github.com/lei2rock/blog"><i class="fab fa-fw fa-github"></i>Lei2rock/Blog</a>基础上进行的修改，感谢班班，原博客地址：<a href="https://blog.dlzhang.com/">https://blog.dlzhang.com</a></p>
]]></content>
  </entry>
  <entry>
    <title>维特比算法</title>
    <url>//posts/null/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>NLP</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
</search>
